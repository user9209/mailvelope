<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Mailvelope API Source: mailvelope-client-api.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Mailvelope API</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Editor.html">Editor</a></li><li><a href="Generator.html">Generator</a></li><li><a href="KeyBackupPopup.html">KeyBackupPopup</a></li><li><a href="Keyring.html">Keyring</a></li><li><a href="Mailvelope.html">Mailvelope</a></li><li><a href="OpenPGPEncryptedForm.html">OpenPGPEncryptedForm</a></li><li><a href="RestoreBackup.html">RestoreBackup</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-Readme.html">Readme</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#mailvelope">mailvelope</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: mailvelope-client-api.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2014-2015 Mailvelope GmbH
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* eslint strict: 0 */
'use strict';

(function() {
  /**
   * Not accessible, see {@tutorial Readme} instead on how to obtain access to an instance.
   */
  class Mailvelope {
    /**
     * Gives access to the mailvelope extension version
     * @returns {Promise.&lt;String, Error>}
     */
    getVersion() {
      return postMessage('get-version');
    }

    /**
     * Retrieves the Keyring for the given identifier
     * @param {string} identifier - the identifier of the keyring
     * @returns {Promise.&lt;Keyring, Error>}
     * @throws {Error} error.code = 'NO_KEYRING_FOR_ID'
     */
    getKeyring(identifier) {
      return postMessage('get-keyring', {identifier}).then(options => new Keyring(identifier, options));
    }

    /**
     * Creates a Keyring for the given identifier
     * @param {string} identifier - the identifier of the new keyring
     * @returns {Promise.&lt;Keyring, Error>}
     * @throws {Error} error.code = 'KEYRING_ALREADY_EXISTS'
     * @example
     * mailvelope.createKeyring('Account-ID-4711').then(function(keyring) {
     *     // continue to display the settings container and start the setup wizard
     *     mailvelope.createSettingsContainer('#mailvelope-settings', keyring);
     * });
     */
    createKeyring(identifier) {
      return postMessage('create-keyring', {identifier}).then(options => new Keyring(identifier, options));
    }

    /**
     * Ascii Armored PGP Text Block
     * @typedef {string} AsciiArmored
     */

    /**
     * CSS Selector String
     * @typedef {string} CssSelector
     */

    /**
     * @typedef {Object} DisplayContainerOptions
     * @property {boolean} showExternalContent - if true loads external content into the display container (default: true)
     * @property {string} senderAddress - email address of sender, used to indentify key for signature verification
     */

    /**
     * @typedef {Object} DisplayContainer
     * @property {Error} error - Error object with code and message attribute
     *                   error.code = 'DECRYPT_ERROR' - generic decrypt error
     *                   error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message
     *                   error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog
     *                   error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message
     */

    /**
     * Creates an iframe to display the decrypted content of the encrypted mail.
     * The iframe will be injected into the container identified by selector.
     * @param {CssSelector} selector - target container
     * @param {AsciiArmored} armored - the encrypted mail to display
     * @param {Keyring} keyring - the keyring to use for this operation
     * @param {DisplayContainerOptions} options
     * @returns {Promise.&lt;DisplayContainer, Error>}
     */
    createDisplayContainer(selector, armored, keyring, options) {
      try {
        checkTypeKeyring(keyring);
      } catch (e) {
        return Promise.reject(e);
      }
      return postMessage('display-container', {selector, armored, identifier: keyring.identifier, options}).then(display => {
        if (display &amp;&amp; display.error) {
          display.error = mapError(display.error);
        }
        return display;
      });
    }

    /**
     * @typedef {Object} EditorContainerOptions
     * @property {number} quota - mail content (text + attachments) limit in kilobytes (default: 20480)
     * @property {boolean} signMsg - if true then the mail will be signed (default: false)
     * @property {AsciiArmored} armoredDraft - a PGP message, signed and encrypted with the default key of the user, will be used to restore a draft in the editor
     *                                         The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments
     * @property {string} predefinedText - text that will be added to the editor
     * @property {AsciiArmored} quotedMail - mail that should be quoted
     * @property {boolean} quotedMailIndent - if true the quoted mail will be indented (default: true)
     * @property {string} quotedMailHeader - header to be added before the quoted mail
     * @property {boolean} keepAttachments - add attachments of quotedMail to editor (default: false)
     */

    /**
     * Creates an iframe with an editor for a new encrypted mail.
     * The iframe will be injected into the container identified by selector.
     * @param {CssSelector} selector - target container
     * @param {Keyring} keyring - the keyring to use for this operation
     * @param {EditorContainerOptions} options
     * @returns {Promise.&lt;Editor, Error>}
     * @throws {Error} error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type &lt;br>
                       error.code = 'INVALID_OPTIONS' - invalid combination of options parameter
     * @example
     * mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) {
     *     // register event handler for mail client send button
     *     $('#mailer-send').click(function() {
     *         // encrypt current content of editor for array of recipients
     *         editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) {
     *           console.log('encrypted message', armored);
     *         });
     *     });
     * });
     */
    createEditorContainer(selector, keyring, options) {
      try {
        checkTypeKeyring(keyring);
      } catch (e) {
        return Promise.reject(e);
      }
      return postMessage('editor-container', {selector, identifier: keyring.identifier, options}).then(editorId => new Editor(editorId));
    }

    /**
     * @typedef {Object} SettingsContainerOptions
     * @property {string} email - the email address of the current user
     * @property {string} fullName - the full name of the current user
     */

    /**
     * Creates an iframe to display the keyring settings.
     * The iframe will be injected into the container identified by selector.
     * @param {CssSelector} selector - target container
     * @param {Keyring} keyring - the keyring to use for the setup
     * @param {SettingsContainerOptions} options
     * @returns {Promise.&lt;undefined, Error>}
     */
    createSettingsContainer(selector, keyring, options) {
      try {
        checkTypeKeyring(keyring);
      } catch (e) {
        return Promise.reject(e);
      }
      return postMessage('settings-container', {selector, identifier: keyring.identifier, options});
    }

    /**
     * Creates an iframe to display an encrypted form
     * The iframe will be injected into the container identified by selector.
     * @param @param {string} selector - the id of target container
     * @param @param {string} formHtml - the form definition
     * @param @param {string} signature - the OpenPGP signature
     * @returns {Promise.&lt;Object, Error>} an object that includes armoredData
     * @throws {Error} error.code = 'INVALID_FORM' the form definition is not valid
     */
    createEncryptedFormContainer(selector, formHtml, signature) {
      return postMessage('encrypted-form-container', {selector, formHtml, signature});
    }
  }

  // connection to content script is alive
  let connected = true;

  let syncHandler = null;

  function checkTypeKeyring(keyring) {
    if (!(keyring instanceof Keyring)) {
      const error = new Error('Type mismatch: keyring should be instance of Keyring.');
      error.code = 'TYPE_MISMATCH';
      throw error;
    }
  }

  /**
   * Not accessible, instance can be obtained using {@link Mailvelope#getKeyring}
   * or {@link Mailvelope#createKeyring}.
   * @param {string} identifier - the keyring identifier
   * @param {object} options - the options
   * @property {number} logoRev - revision number of the keyring logo, initial value: 0
   */
  class Keyring {
    constructor(identifier, options) {
      this.identifier = identifier;
      this.logoRev = options.revision || 0;
    }

    /**
     * Checks for valid key in the keyring for provided email addresses
     * @param  {Array} recipients - list of email addresses for key lookup
     * @return {Promise.&lt;Object, Error>} an object that maps email addresses to a status or key info object (false: no valid key, {}: valid key)
     * @example
     * keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) {
     *     console.log(result);
     * // {
     * //   'abc@web.de': false,
     * //   'info@mailvelope.com': {
     * //     keys: [
     * //       {fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST)}
     * //     ]
     * // }
     * });
     */
    validKeyForAddress(recipients) {
      return postMessage('query-valid-key', {identifier: this.identifier, recipients}).then(keyMap => {
        for (const address in keyMap) {
          if (keyMap[address]) {
            keyMap[address].keys.forEach(key => {
              key.lastModified = new Date(key.lastModified);
            });
          }
        }
        return keyMap;
      });
    }

    /**
     * Exports the public key as an ascii armored string.
     * Only keys belonging to the user (corresponding private key exists) can be exported.
     * @param {string} emailAddr - email address to identify the public+private key
     * @returns {Promise.&lt;AsciiArmored, Error>}
     * @throws {Error} error.code = 'NO_KEY_FOR_ADDRESS'
     * @example
     * keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) {
     *   console.log('exportOwnPublicKey', armoredPublicKey); // prints: "-----BEGIN PGP PUBLIC KEY BLOCK..."
     * });
     */
    exportOwnPublicKey(emailAddr) {
      return postMessage('export-own-pub-key', {identifier: this.identifier, emailAddr});
    }

    /**
     * Asks the user if they want to import the public key.
     * @param {AsciiArmored} armored - public key to import
     * @returns {Promise.&lt;String, Error>} 'IMPORTED' - key has been imported &lt;br>
                                          'UPDATED' - key already in keyring, new key merged with existing key &lt;br>
                                          'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) &lt;br>
                                          'REJECTED' - key import rejected by user
     * @throws {Error} error.code = 'IMPORT_ERROR' &lt;br>
                       error.code = 'WRONG_ARMORED_TYPE'
     */
    importPublicKey(armored) {
      return postMessage('import-pub-key', {identifier: this.identifier, armored});
    }

    /**
     * Set logo for keyring. The image is persisted in Mailvelope with a revision number,
     * therefore the method is only required after new keyring generation or if logo and revision number changes.
     * @param {string} dataURL  - data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png
     * @param {number} revision - revision number
     * @returns {Promise.&lt;undefined, Error>}
     * @throws {Error} error.code = 'LOGO_INVALID' &lt;br>
     *                 error.code = 'REVISION_INVALID'
     * @example
     * keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() {
     *   // keyring.logoRev == 3
     * }).catch(function(error) {
     *   // logo update failed
     * });
     *
     */
    setLogo(dataURL, revision) {
      return postMessage('set-logo', {identifier: this.identifier, dataURL, revision}).then(() => {
        this.logoRev = revision;
      });
    }

    /**
     * @typedef {Object} UserId
     * @property {string} email - the email address of the current user
     * @property {string} fullName - the full name of the current user
     */

    /**
     * @typedef {Object} KeyGenContainerOptions
     * @property {Array.&lt;UserId>} userIds - array of user IDs. The first entry in the array is set as the primary user ID.
     * @property {number} keySize - key size in bit, optional, default: 2048, valid values: 2048, 4096.
     */

    /**
     * Creates an iframe to display the key generation container.
     * The iframe will be injected into the container identified by selector.
     * @param {CssSelector} selector - target container
     * @param {KeyGenContainerOptions} options
     * @returns {Promise.&lt;Generator, Error>}
     * @throws {Error} error.code = 'INPUT_NOT_VALID'
     */
    createKeyGenContainer(selector, options) {
      return postMessage('key-gen-container', {selector, identifier: this.identifier, options}).then(generatorId => new Generator(generatorId));
    }

    /**
     * @typedef {Object} KeyBackupContainerOptions
     * @param {Boolean} initialSetup (default: true)
     */

    /**
     * Creates an iframe to initiate the key backup process.
     * @param {CssSelector} selector - target container
     * @param {KeyBackupContainerOptions} options
     * @returns {Promise.&lt;KeyBackupPopup, Error>}
     */
    createKeyBackupContainer(selector, options) {
      return postMessage('key-backup-container', {selector, identifier: this.identifier, options}).then(popupId => new KeyBackupPopup(popupId));
    }

    /**
     * @typedef {Object} PrivateKeyContainerOptions
     * @property {boolean} restorePassword (default: false)
     */

    /**
     * Creates an iframe to restore the backup.
     * @param {CssSelector} selector - target container
     * @param {PrivateKeyContainerOptions} options
     * @returns {Promise.&lt;undefined, Error>}
     */
    restoreBackupContainer(selector, options) {
      return postMessage('restore-backup-container', {selector, identifier: this.identifier, options}).then(restoreId => new RestoreBackup(restoreId));
    }

    /**
     * Check if keyring contains valid private key with given fingerprint
     * @param {string} fingerprint
     * @returns {Promise.&lt;boolean, Error>}
     */
    hasPrivateKey(fingerprint) {
      return postMessage('has-private-key', {identifier: this.identifier, fingerprint}).then(result => result);
    }

    /**
     * @typedef {Object} UploadSyncReply
     * @property {String} eTag - entity tag for the uploaded encrypted keyring
     */

    /**
     * @typedef {Function} UploadSyncHandler
     * @param {Object} uploadObj - object with upload data
     * @param {string} uploadObj.eTag - entity tag for the uploaded encrypted keyring, or null if initial upload
     * @param {AsciiArmored} uploadObj.keyringMsg - encrypted keyring as PGP armored message
     * @returns {Promise.&lt;UploadSyncReply, Error>} - if version on server has different eTag, then the promise is rejected
     *                                               if server is initial and uploadObj.eTag is not null, then the promise is rejected
     */

    /**
     * @typedef {Object} DownloadSyncReply
     * @property {AsciiArmored} keyringMsg - encrypted keyring as PGP armored message, or null if no newer version available
     * @property {String} eTag - entity tag for the current encrypted keyring message, or null if server is intial
     */

    /**
     * @typedef {Function} DownloadSyncHandler
     * @param {Object} downloadObj - meta info for download
     * @param {string} downloadObj.eTag - entity tag for the current local keyring, or null if no local eTag
     * @returns {Promise.&lt;DownloadSyncReply, Error>} - if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set
     *                                                 if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag
     */

    /**
     * @typedef {Object} BackupSyncPacket
     * @property {AsciiArmored} backup - encrypted key backup as PGP armored message
     */

    /**
     * @typedef {Function} BackupSyncHandler
     * @param {BackupSyncPacket} - object with backup data
     * @returns {Promise.&lt;undefined, Error>}
     */

    /**
     * @typedef {Function} RestoreSyncHandler
     * @returns {Promise.&lt;BackupSyncPacket, Error>}
     */

    /**
     * @typedef {Object} SyncHandlerObject
     * @property {UploadSyncHandler} uploadSync - function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the default private key
     * @property {DownloadSyncHandler} downloadSync - function called by Mailvelope to download the encrypted keyring (public keys)
     * @property {BackupSyncHandler} backup - function called by Mailvelope to upload a symmetrically encrypted private key backup
     * @property {RestoreSyncHandler} restore - function called by Mailvelope to restore a private key backup
     */

    /**
     * Add various functions for keyring synchronization
     * @param {SyncHandlerObject} syncHandlerObj
     * @returns {Promise.&lt;undefined, Error>}
     */
    addSyncHandler(syncHandlerObj) {
      if (typeof syncHandlerObj.uploadSync !== typeof syncHandlerObj.downloadSync) {
        return Promise.reject(new Error('uploadSync and downloadSync Handler cannot be set exclusively.'));
      }
      return postMessage('add-sync-handler', {identifier: this.identifier}).then(syncHandlerId => {
        if (syncHandler) {
          syncHandler.update(syncHandlerObj);
        } else {
          syncHandler = new SyncHandler(syncHandlerId, syncHandlerObj);
        }
      });
    }

    /**
     * Open the extension settings in a new browser tab
     * @returns {Promise.&lt;undefined, Error>}
     */
    openSettings() {
      return postMessage('open-settings', {identifier: this.identifier});
    }
  }

  /**
   * Not accessible, instance can be obtained using {@link Keyring#createKeyBackupContainer}
   * @param {string} popupId
   */
  class KeyBackupPopup {
    constructor(popupId) {
      this.popupId = popupId;
    }

    /**
     * @returns {Promise.&lt;undefined, Error>} - key backup ready or error
     * @throws {Error}
     */
    isReady() {
      return postMessage('keybackup-popup-isready', {popupId: this.popupId});
    }
  }

  /**
   * Not accessible, instance can be obtained using {@link Keyring#createKeyGenContainer}.
   * @param {string} generatorId - the internal id of the generator
   */
  class Generator {
    constructor(generatorId) {
      this.generatorId = generatorId;
    }

    /**
     * Generate a private key
     * @param {Promise.&lt;undefined, Error>} [confirm] - newly generate key is only persisted if Promise resolves,
     *                                                 in the reject or timeout case the generated key is rejected
     * @returns {Promise.&lt;AsciiArmored, Error>} - the newly generated key (public part)
     * @throws {Error}
     */
    generate(confirm) {
      return postMessage('generator-generate', {generatorId: this.generatorId, confirmRequired: Boolean(confirm)}).then(armored => {
        if (confirm) {
          confirm.then(() => {
            postMessage('generator-generate-confirm', {generatorId: this.generatorId});
          }).catch(e => {
            postMessage('generator-generate-reject', {generatorId: this.generatorId, error: e});
          });
        }
        return armored;
      });
    }
  }

  /**
   * Not accessible, instance can be obtained using {@link Keyring#restoreBackupContainer}.
   * @param {string} restoreId - the internal id of the restore backup
   */
  class RestoreBackup {
    constructor(restoreId) {
      this.restoreId = restoreId;
    }

    /**
     * @returns {Promise.&lt;undefined, Error>} - key restore ready or error
     * @throws {Error}
     */
    isReady() {
      return postMessage('restore-backup-isready', {restoreId: this.restoreId});
    }
  }

  /**
   * Not accessible, instance can be obtained using {@link Mailvelope#createEditorContainer}.
   * @param {string} editorId - the internal id of the editor
   */
  class Editor {
    constructor(editorId) {
      this.editorId = editorId;
    }

    /**
     * Requests the encryption of the editor content for the given recipients.
     * @param {Array.&lt;string>} recipients - list of email addresses for public key lookup and encryption
     * @returns {Promise.&lt;AsciiArmored, Error>}
     * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br>
     *                 error.code = 'NO_KEY_FOR_RECIPIENT' &lt;br>
     *                 error.code = 'ENCRYPT_QUOTA_SIZE'
     * @example
     * editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) {
     *     console.log('encrypt', armoredMessage); // prints: "-----BEGIN PGP MESSAGE..."
     * }
     */
    encrypt(recipients) {
      return postMessage('editor-encrypt', {recipients, editorId: this.editorId});
    }

    /**
     * Encrypt and sign the content of the editor with the default key of the user.
     * To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method.
     * @returns {Promise.&lt;AsciiArmored, Error>}
     * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br>
     *                 error.code = 'NO_KEY_FOR_ENCRYPTION' &lt;br>
     *                 error.code = 'ENCRYPT_QUOTA_SIZE'
     */
    createDraft() {
      return postMessage('editor-create-draft', {editorId: this.editorId});
    }
  }

  const callbacks = Object.create(null);

  class SyncHandler {
    constructor(syncHandlerId, handlers) {
      this.syncHandlerId = syncHandlerId;
      this.handlers = handlers;
    }

    update(handlers) {
      for (const handle in handlers) {
        this.handlers[handle] = handlers[handle];
      }
    }
  }

  function handleSyncEvent(msg) {
    let handler = null;
    switch (msg.data.type) {
      case 'upload':
        handler = syncHandler.handlers.uploadSync;
        break;
      case 'download':
        handler = syncHandler.handlers.downloadSync;
        break;
      case 'backup':
        handler = syncHandler.handlers.backup;
        break;
      case 'restore':
        handler = syncHandler.handlers.restore;
        break;
      default:
        console.log('mailvelope-client-api unknown sync event', msg.data.type);
    }
    if (!handler) {
      postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, error: {message: 'Sync handler not available'}, id: msg.data.id}, true);
      return;
    }
    handler(msg.data.data)
    .then(result => {
      postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, syncData: result, id: msg.data.id}, true);
    })
    .catch(error => {
      if (!error) {
        error = new Error('Unknown Error');
      }
      if (error instanceof Error || typeof error === 'string') {
        error = {message: error.message || String(error)};
      }
      postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, error, id: msg.data.id}, true);
    });
  }

  function eventListener(event) {
    if (event.origin !== window.location.origin ||
        event.data.mvelo_client ||
        !event.data.mvelo_extension) {
      return;
    }
    //console.log('clientAPI eventListener', event.data);
    switch (event.data.event) {
      case 'sync-event':
        handleSyncEvent(event.data);
        break;
      case 'callback-reply': {
        let error;
        if (event.data.error) {
          error = new Error(event.data.error.message);
          error.code = event.data.error.code;
          if (!callbacks[event.data.id]) {
            throw error;
          }
        }
        callbacks[event.data.id](error, event.data.data);
        delete callbacks[event.data.id];
        break;
      }
      default:
        console.log('mailvelope-client-api unknown event', event.data.event);
    }
  }

  function disconnectListener() {
    window.removeEventListener('message', eventListener);
    connected = false;
  }

  function getHash() {
    let result = '';
    const buf = new Uint16Array(6);
    window.crypto.getRandomValues(buf);
    for (let i = 0; i &lt; buf.length; i++) {
      result += buf[i].toString(16);
    }
    return result;
  }

  function mapError(obj) {
    const error = new Error(obj.message);
    error.code = obj.code;
    return error;
  }

  function postMessage(eventName, data, noResp) {
    if (!connected) {
      const error = new Error('Connection to Mailvelope extension is no longer alive.');
      error.code = 'NO_CONNECTION';
      throw error;
    }
    return new Promise((resolve, reject) => {
      const message = {
        event: eventName,
        mvelo_client: true,
        data,
        id: getHash()
      };
      if (!noResp) {
        callbacks[message.id] = function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        };
      }
      window.postMessage(message, window.location.origin);
    });
  }

  /**
   * Global instance of {@link Mailvelope}
   * @global
   * @type {Mailvelope}
   */
  window.mailvelope = new Mailvelope();

  window.addEventListener('message', eventListener);
  window.addEventListener('mailvelope-disconnect', disconnectListener);

  window.setTimeout(() => {
    window.dispatchEvent(new CustomEvent('mailvelope', {detail: window.mailvelope}));
  }, 1);

  /**
   * OpenPGPEncryptedForm custom HTMLElement
   */
  class OpenPGPEncryptedForm extends HTMLElement {
    // Invoked when the custom element is first connected to the document's DOM.
    connectedCallback() {
      this.dispatchEvent(new Event('connected'));
      const id = this.getAttribute('id');
      if (!id) {
        const error = new Error('No form id for openpgp-encrypted-tag. Please add a unique identifier.');
        error.code = 'NO_FORM_ID';
        return this.onError(error);
      }
      let html;
      const scriptTags = this.getElementsByTagName('script');
      if (scriptTags.length) {
        html = scriptTags[0].innerText;
      } else {
        const error = new Error('No form template for openpgp-encrypted-tag. Please add a form template.');
        error.code = 'NO_FORM_SCRIPT';
        return this.onError(error);
      }
      window.mailvelope.createEncryptedFormContainer(`#${id}`, html, this.getAttribute('signature'))
      .then(data => this.onEncrypt(data), error => this.onError(error));
    }

    onEncrypt(data) {
      this.dispatchEvent(new CustomEvent('encrypt', {
        detail: {armoredData: data.armoredData},
        bubbles: true,
        cancelable: true
      }));
    }

    onError(error) {
      this.dispatchEvent(new ErrorEvent('error', {
        message: error.message,
        error
      }));
    }
  }

  // See. https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements#Specification#Browser_compatibility
  if (typeof window.customElements !== 'undefined') {
    window.customElements.define('openpgp-encrypted-form', OpenPGPEncryptedForm);
  }
}());
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	Â© 2014-2016 Mailvelope GmbH
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
		on Wed Dec 19th 2018
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
