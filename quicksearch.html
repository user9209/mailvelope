<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"mailvelope-client-api.js.html":{"id":"mailvelope-client-api.js.html","title":"Source: mailvelope-client-api.js","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Source: mailvelope-client-api.js /** * The MIT License (MIT) * * Copyright (c) 2014-2015 Mailvelope GmbH * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ /* eslint strict: 0 */ 'use strict'; (function() { /** * Not accessible, see {@tutorial Readme} instead on how to obtain access to an instance. */ class Mailvelope { /** * Gives access to the mailvelope extension version * @returns {Promise.&lt;String, Error&gt;} */ getVersion() { return postMessage('get-version'); } /** * Retrieves the Keyring for the given identifier * @param {string} identifier - the identifier of the keyring * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'NO_KEYRING_FOR_ID' */ getKeyring(identifier) { return postMessage('get-keyring', {identifier}).then(options =&gt; new Keyring(identifier, options)); } /** * Creates a Keyring for the given identifier * @param {string} identifier - the identifier of the new keyring * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'KEYRING_ALREADY_EXISTS' * @example * mailvelope.createKeyring('Account-ID-4711').then(function(keyring) { * // continue to display the settings container and start the setup wizard * mailvelope.createSettingsContainer('#mailvelope-settings', keyring); * }); */ createKeyring(identifier) { return postMessage('create-keyring', {identifier}).then(options =&gt; new Keyring(identifier, options)); } /** * Ascii Armored PGP Text Block * @typedef {string} AsciiArmored */ /** * CSS Selector String * @typedef {string} CssSelector */ /** * @typedef {Object} DisplayContainerOptions * @property {boolean} showExternalContent - if true loads external content into the display container (default: true) * @property {string} senderAddress - email address of sender, used to indentify key for signature verification */ /** * @typedef {Object} DisplayContainer * @property {Error} error - Error object with code and message attribute * error.code = 'DECRYPT_ERROR' - generic decrypt error * error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message * error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog * error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message */ /** * Creates an iframe to display the decrypted content of the encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {AsciiArmored} armored - the encrypted mail to display * @param {Keyring} keyring - the keyring to use for this operation * @param {DisplayContainerOptions} options * @returns {Promise.&lt;DisplayContainer, Error&gt;} */ createDisplayContainer(selector, armored, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return postMessage('display-container', {selector, armored, identifier: keyring.identifier, options}).then(display =&gt; { if (display &amp;&amp; display.error) { display.error = mapError(display.error); } return display; }); } /** * @typedef {Object} EditorContainerOptions * @property {number} quota - mail content (text + attachments) limit in kilobytes (default: 20480) * @property {boolean} signMsg - if true then the mail will be signed (default: false) * @property {AsciiArmored} armoredDraft - a PGP message, signed and encrypted with the default key of the user, will be used to restore a draft in the editor * The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments * @property {string} predefinedText - text that will be added to the editor * @property {AsciiArmored} quotedMail - mail that should be quoted * @property {boolean} quotedMailIndent - if true the quoted mail will be indented (default: true) * @property {string} quotedMailHeader - header to be added before the quoted mail * @property {boolean} keepAttachments - add attachments of quotedMail to editor (default: false) */ /** * Creates an iframe with an editor for a new encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} keyring - the keyring to use for this operation * @param {EditorContainerOptions} options * @returns {Promise.&lt;Editor, Error&gt;} * @throws {Error} error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type &lt;br&gt; error.code = 'INVALID_OPTIONS' - invalid combination of options parameter * @example * mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) { * // register event handler for mail client send button * $('#mailer-send').click(function() { * // encrypt current content of editor for array of recipients * editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) { * console.log('encrypted message', armored); * }); * }); * }); */ createEditorContainer(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return postMessage('editor-container', {selector, identifier: keyring.identifier, options}).then(editorId =&gt; new Editor(editorId)); } /** * @typedef {Object} SettingsContainerOptions * @property {string} email - the email address of the current user * @property {string} fullName - the full name of the current user */ /** * Creates an iframe to display the keyring settings. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} keyring - the keyring to use for the setup * @param {SettingsContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ createSettingsContainer(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return postMessage('settings-container', {selector, identifier: keyring.identifier, options}); } /** * Creates an iframe to display an encrypted form * The iframe will be injected into the container identified by selector. * @param @param {string} selector - the id of target container * @param @param {string} formHtml - the form definition * @param @param {string} signature - the OpenPGP signature * @returns {Promise.&lt;Object, Error&gt;} an object that includes armoredData * @throws {Error} error.code = 'INVALID_FORM' the form definition is not valid */ createEncryptedFormContainer(selector, formHtml, signature) { return postMessage('encrypted-form-container', {selector, formHtml, signature}); } } // connection to content script is alive let connected = true; let syncHandler = null; function checkTypeKeyring(keyring) { if (!(keyring instanceof Keyring)) { const error = new Error('Type mismatch: keyring should be instance of Keyring.'); error.code = 'TYPE_MISMATCH'; throw error; } } /** * Not accessible, instance can be obtained using {@link Mailvelope#getKeyring} * or {@link Mailvelope#createKeyring}. * @param {string} identifier - the keyring identifier * @param {object} options - the options * @property {number} logoRev - revision number of the keyring logo, initial value: 0 */ class Keyring { constructor(identifier, options) { this.identifier = identifier; this.logoRev = options.revision || 0; } /** * Checks for valid key in the keyring for provided email addresses * @param {Array} recipients - list of email addresses for key lookup * @return {Promise.&lt;Object, Error&gt;} an object that maps email addresses to a status or key info object (false: no valid key, {}: valid key) * @example * keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) { * console.log(result); * // { * // 'abc@web.de': false, * // 'info@mailvelope.com': { * // keys: [ * // {fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST)} * // ] * // } * }); */ validKeyForAddress(recipients) { return postMessage('query-valid-key', {identifier: this.identifier, recipients}).then(keyMap =&gt; { for (const address in keyMap) { if (keyMap[address]) { keyMap[address].keys.forEach(key =&gt; { key.lastModified = new Date(key.lastModified); }); } } return keyMap; }); } /** * Exports the public key as an ascii armored string. * Only keys belonging to the user (corresponding private key exists) can be exported. * @param {string} emailAddr - email address to identify the public+private key * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'NO_KEY_FOR_ADDRESS' * @example * keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) { * console.log('exportOwnPublicKey', armoredPublicKey); // prints: \"-----BEGIN PGP PUBLIC KEY BLOCK...\" * }); */ exportOwnPublicKey(emailAddr) { return postMessage('export-own-pub-key', {identifier: this.identifier, emailAddr}); } /** * Asks the user if they want to import the public key. * @param {AsciiArmored} armored - public key to import * @returns {Promise.&lt;String, Error&gt;} 'IMPORTED' - key has been imported &lt;br&gt; 'UPDATED' - key already in keyring, new key merged with existing key &lt;br&gt; 'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) &lt;br&gt; 'REJECTED' - key import rejected by user * @throws {Error} error.code = 'IMPORT_ERROR' &lt;br&gt; error.code = 'WRONG_ARMORED_TYPE' */ importPublicKey(armored) { return postMessage('import-pub-key', {identifier: this.identifier, armored}); } /** * Set logo for keyring. The image is persisted in Mailvelope with a revision number, * therefore the method is only required after new keyring generation or if logo and revision number changes. * @param {string} dataURL - data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png * @param {number} revision - revision number * @returns {Promise.&lt;undefined, Error&gt;} * @throws {Error} error.code = 'LOGO_INVALID' &lt;br&gt; * error.code = 'REVISION_INVALID' * @example * keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() { * // keyring.logoRev == 3 * }).catch(function(error) { * // logo update failed * }); * */ setLogo(dataURL, revision) { return postMessage('set-logo', {identifier: this.identifier, dataURL, revision}).then(() =&gt; { this.logoRev = revision; }); } /** * @typedef {Object} UserId * @property {string} email - the email address of the current user * @property {string} fullName - the full name of the current user */ /** * @typedef {Object} KeyGenContainerOptions * @property {Array.&lt;UserId&gt;} userIds - array of user IDs. The first entry in the array is set as the primary user ID. * @property {number} keySize - key size in bit, optional, default: 2048, valid values: 2048, 4096. */ /** * Creates an iframe to display the key generation container. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {KeyGenContainerOptions} options * @returns {Promise.&lt;Generator, Error&gt;} * @throws {Error} error.code = 'INPUT_NOT_VALID' */ createKeyGenContainer(selector, options) { return postMessage('key-gen-container', {selector, identifier: this.identifier, options}).then(generatorId =&gt; new Generator(generatorId)); } /** * @typedef {Object} KeyBackupContainerOptions * @param {Boolean} initialSetup (default: true) */ /** * Creates an iframe to initiate the key backup process. * @param {CssSelector} selector - target container * @param {KeyBackupContainerOptions} options * @returns {Promise.&lt;KeyBackupPopup, Error&gt;} */ createKeyBackupContainer(selector, options) { return postMessage('key-backup-container', {selector, identifier: this.identifier, options}).then(popupId =&gt; new KeyBackupPopup(popupId)); } /** * @typedef {Object} PrivateKeyContainerOptions * @property {boolean} restorePassword (default: false) */ /** * Creates an iframe to restore the backup. * @param {CssSelector} selector - target container * @param {PrivateKeyContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ restoreBackupContainer(selector, options) { return postMessage('restore-backup-container', {selector, identifier: this.identifier, options}).then(restoreId =&gt; new RestoreBackup(restoreId)); } /** * Check if keyring contains valid private key with given fingerprint * @param {string} fingerprint * @returns {Promise.&lt;boolean, Error&gt;} */ hasPrivateKey(fingerprint) { return postMessage('has-private-key', {identifier: this.identifier, fingerprint}).then(result =&gt; result); } /** * @typedef {Object} UploadSyncReply * @property {String} eTag - entity tag for the uploaded encrypted keyring */ /** * @typedef {Function} UploadSyncHandler * @param {Object} uploadObj - object with upload data * @param {string} uploadObj.eTag - entity tag for the uploaded encrypted keyring, or null if initial upload * @param {AsciiArmored} uploadObj.keyringMsg - encrypted keyring as PGP armored message * @returns {Promise.&lt;UploadSyncReply, Error&gt;} - if version on server has different eTag, then the promise is rejected * if server is initial and uploadObj.eTag is not null, then the promise is rejected */ /** * @typedef {Object} DownloadSyncReply * @property {AsciiArmored} keyringMsg - encrypted keyring as PGP armored message, or null if no newer version available * @property {String} eTag - entity tag for the current encrypted keyring message, or null if server is intial */ /** * @typedef {Function} DownloadSyncHandler * @param {Object} downloadObj - meta info for download * @param {string} downloadObj.eTag - entity tag for the current local keyring, or null if no local eTag * @returns {Promise.&lt;DownloadSyncReply, Error&gt;} - if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set * if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag */ /** * @typedef {Object} BackupSyncPacket * @property {AsciiArmored} backup - encrypted key backup as PGP armored message */ /** * @typedef {Function} BackupSyncHandler * @param {BackupSyncPacket} - object with backup data * @returns {Promise.&lt;undefined, Error&gt;} */ /** * @typedef {Function} RestoreSyncHandler * @returns {Promise.&lt;BackupSyncPacket, Error&gt;} */ /** * @typedef {Object} SyncHandlerObject * @property {UploadSyncHandler} uploadSync - function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the default private key * @property {DownloadSyncHandler} downloadSync - function called by Mailvelope to download the encrypted keyring (public keys) * @property {BackupSyncHandler} backup - function called by Mailvelope to upload a symmetrically encrypted private key backup * @property {RestoreSyncHandler} restore - function called by Mailvelope to restore a private key backup */ /** * Add various functions for keyring synchronization * @param {SyncHandlerObject} syncHandlerObj * @returns {Promise.&lt;undefined, Error&gt;} */ addSyncHandler(syncHandlerObj) { if (typeof syncHandlerObj.uploadSync !== typeof syncHandlerObj.downloadSync) { return Promise.reject(new Error('uploadSync and downloadSync Handler cannot be set exclusively.')); } return postMessage('add-sync-handler', {identifier: this.identifier}).then(syncHandlerId =&gt; { if (syncHandler) { syncHandler.update(syncHandlerObj); } else { syncHandler = new SyncHandler(syncHandlerId, syncHandlerObj); } }); } /** * Open the extension settings in a new browser tab * @returns {Promise.&lt;undefined, Error&gt;} */ openSettings() { return postMessage('open-settings', {identifier: this.identifier}); } } /** * Not accessible, instance can be obtained using {@link Keyring#createKeyBackupContainer} * @param {string} popupId */ class KeyBackupPopup { constructor(popupId) { this.popupId = popupId; } /** * @returns {Promise.&lt;undefined, Error&gt;} - key backup ready or error * @throws {Error} */ isReady() { return postMessage('keybackup-popup-isready', {popupId: this.popupId}); } } /** * Not accessible, instance can be obtained using {@link Keyring#createKeyGenContainer}. * @param {string} generatorId - the internal id of the generator */ class Generator { constructor(generatorId) { this.generatorId = generatorId; } /** * Generate a private key * @param {Promise.&lt;undefined, Error&gt;} [confirm] - newly generate key is only persisted if Promise resolves, * in the reject or timeout case the generated key is rejected * @returns {Promise.&lt;AsciiArmored, Error&gt;} - the newly generated key (public part) * @throws {Error} */ generate(confirm) { return postMessage('generator-generate', {generatorId: this.generatorId, confirmRequired: Boolean(confirm)}).then(armored =&gt; { if (confirm) { confirm.then(() =&gt; { postMessage('generator-generate-confirm', {generatorId: this.generatorId}); }).catch(e =&gt; { postMessage('generator-generate-reject', {generatorId: this.generatorId, error: e}); }); } return armored; }); } } /** * Not accessible, instance can be obtained using {@link Keyring#restoreBackupContainer}. * @param {string} restoreId - the internal id of the restore backup */ class RestoreBackup { constructor(restoreId) { this.restoreId = restoreId; } /** * @returns {Promise.&lt;undefined, Error&gt;} - key restore ready or error * @throws {Error} */ isReady() { return postMessage('restore-backup-isready', {restoreId: this.restoreId}); } } /** * Not accessible, instance can be obtained using {@link Mailvelope#createEditorContainer}. * @param {string} editorId - the internal id of the editor */ class Editor { constructor(editorId) { this.editorId = editorId; } /** * Requests the encryption of the editor content for the given recipients. * @param {Array.&lt;string&gt;} recipients - list of email addresses for public key lookup and encryption * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_RECIPIENT' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' * @example * editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) { * console.log('encrypt', armoredMessage); // prints: \"-----BEGIN PGP MESSAGE...\" * } */ encrypt(recipients) { return postMessage('editor-encrypt', {recipients, editorId: this.editorId}); } /** * Encrypt and sign the content of the editor with the default key of the user. * To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method. * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_ENCRYPTION' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' */ createDraft() { return postMessage('editor-create-draft', {editorId: this.editorId}); } } const callbacks = Object.create(null); class SyncHandler { constructor(syncHandlerId, handlers) { this.syncHandlerId = syncHandlerId; this.handlers = handlers; } update(handlers) { for (const handle in handlers) { this.handlers[handle] = handlers[handle]; } } } function handleSyncEvent(msg) { let handler = null; switch (msg.data.type) { case 'upload': handler = syncHandler.handlers.uploadSync; break; case 'download': handler = syncHandler.handlers.downloadSync; break; case 'backup': handler = syncHandler.handlers.backup; break; case 'restore': handler = syncHandler.handlers.restore; break; default: console.log('mailvelope-client-api unknown sync event', msg.data.type); } if (!handler) { postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, error: {message: 'Sync handler not available'}, id: msg.data.id}, true); return; } handler(msg.data.data) .then(result =&gt; { postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, syncData: result, id: msg.data.id}, true); }) .catch(error =&gt; { if (!error) { error = new Error('Unknown Error'); } if (error instanceof Error || typeof error === 'string') { error = {message: error.message || String(error)}; } postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, error, id: msg.data.id}, true); }); } function eventListener(event) { if (event.origin !== window.location.origin || event.data.mvelo_client || !event.data.mvelo_extension) { return; } //console.log('clientAPI eventListener', event.data); switch (event.data.event) { case 'sync-event': handleSyncEvent(event.data); break; case 'callback-reply': { let error; if (event.data.error) { error = new Error(event.data.error.message); error.code = event.data.error.code; if (!callbacks[event.data.id]) { throw error; } } callbacks[event.data.id](error, event.data.data); delete callbacks[event.data.id]; break; } default: console.log('mailvelope-client-api unknown event', event.data.event); } } function disconnectListener() { window.removeEventListener('message', eventListener); connected = false; } function getHash() { let result = ''; const buf = new Uint16Array(6); window.crypto.getRandomValues(buf); for (let i = 0; i &lt; buf.length; i++) { result += buf[i].toString(16); } return result; } function mapError(obj) { const error = new Error(obj.message); error.code = obj.code; return error; } function postMessage(eventName, data, noResp) { if (!connected) { const error = new Error('Connection to Mailvelope extension is no longer alive.'); error.code = 'NO_CONNECTION'; throw error; } return new Promise((resolve, reject) =&gt; { const message = { event: eventName, mvelo_client: true, data, id: getHash() }; if (!noResp) { callbacks[message.id] = function(err, data) { if (err) { reject(err); } else { resolve(data); } }; } window.postMessage(message, window.location.origin); }); } /** * Global instance of {@link Mailvelope} * @global * @type {Mailvelope} */ window.mailvelope = new Mailvelope(); window.addEventListener('message', eventListener); window.addEventListener('mailvelope-disconnect', disconnectListener); window.setTimeout(() =&gt; { window.dispatchEvent(new CustomEvent('mailvelope', {detail: window.mailvelope})); }, 1); /** * OpenPGPEncryptedForm custom HTMLElement */ class OpenPGPEncryptedForm extends HTMLElement { // Invoked when the custom element is first connected to the document's DOM. connectedCallback() { this.dispatchEvent(new Event('connected')); const id = this.getAttribute('id'); if (!id) { const error = new Error('No form id for openpgp-encrypted-tag. Please add a unique identifier.'); error.code = 'NO_FORM_ID'; return this.onError(error); } let html; const scriptTags = this.getElementsByTagName('script'); if (scriptTags.length) { html = scriptTags[0].innerText; } else { const error = new Error('No form template for openpgp-encrypted-tag. Please add a form template.'); error.code = 'NO_FORM_SCRIPT'; return this.onError(error); } window.mailvelope.createEncryptedFormContainer(`#${id}`, html, this.getAttribute('signature')) .then(data =&gt; this.onEncrypt(data), error =&gt; this.onError(error)); } onEncrypt(data) { this.dispatchEvent(new CustomEvent('encrypt', { detail: {armoredData: data.armoredData}, bubbles: true, cancelable: true })); } onError(error) { this.dispatchEvent(new ErrorEvent('error', { message: error.message, error })); } } // See. https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements#Specification#Browser_compatibility if (typeof window.customElements !== 'undefined') { window.customElements.define('openpgp-encrypted-form', OpenPGPEncryptedForm); } }()); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Global Members mailvelope :Mailvelope Global instance of Mailvelope Type: Mailvelope Source: mailvelope-client-api.js, line 678 Type Definitions AsciiArmored Ascii Armored PGP Text Block Type: string Source: mailvelope-client-api.js, line 66 BackupSyncHandler() Parameters: Type Description BackupSyncPacket object with backup data Source: mailvelope-client-api.js, line 395 Returns: Type Promise.&lt;undefined, Error&gt; BackupSyncPacket Type: Object Properties: Name Type Description backup AsciiArmored encrypted key backup as PGP armored message Source: mailvelope-client-api.js, line 390 CssSelector CSS Selector String Type: string Source: mailvelope-client-api.js, line 71 DisplayContainer Type: Object Properties: Name Type Description error Error Error object with code and message attribute error.code = 'DECRYPT_ERROR' - generic decrypt error error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message Source: mailvelope-client-api.js, line 82 DisplayContainerOptions Type: Object Properties: Name Type Description showExternalContent boolean if true loads external content into the display container (default: true) senderAddress string email address of sender, used to indentify key for signature verification Source: mailvelope-client-api.js, line 76 DownloadSyncHandler(downloadObj) Parameters: Name Type Description downloadObj Object meta info for download Properties Name Type Description eTag string entity tag for the current local keyring, or null if no local eTag Source: mailvelope-client-api.js, line 382 Returns: if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag Type Promise.&lt;DownloadSyncReply, Error&gt; DownloadSyncReply Type: Object Properties: Name Type Description keyringMsg AsciiArmored encrypted keyring as PGP armored message, or null if no newer version available eTag String entity tag for the current encrypted keyring message, or null if server is intial Source: mailvelope-client-api.js, line 376 EditorContainerOptions Type: Object Properties: Name Type Description quota number mail content (text + attachments) limit in kilobytes (default: 20480) signMsg boolean if true then the mail will be signed (default: false) armoredDraft AsciiArmored a PGP message, signed and encrypted with the default key of the user, will be used to restore a draft in the editor The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments predefinedText string text that will be added to the editor quotedMail AsciiArmored mail that should be quoted quotedMailIndent boolean if true the quoted mail will be indented (default: true) quotedMailHeader string header to be added before the quoted mail keepAttachments boolean add attachments of quotedMail to editor (default: false) Source: mailvelope-client-api.js, line 114 KeyBackupContainerOptions Type: Object Source: mailvelope-client-api.js, line 323 KeyGenContainerOptions Type: Object Properties: Name Type Description userIds Array.&lt;UserId&gt; array of user IDs. The first entry in the array is set as the primary user ID. keySize number key size in bit, optional, default: 2048, valid values: 2048, 4096. Source: mailvelope-client-api.js, line 305 PrivateKeyContainerOptions Type: Object Properties: Name Type Description restorePassword boolean (default: false) Source: mailvelope-client-api.js, line 338 RestoreSyncHandler() Source: mailvelope-client-api.js, line 401 Returns: Type Promise.&lt;BackupSyncPacket, Error&gt; SettingsContainerOptions Type: Object Properties: Name Type Description email string the email address of the current user fullName string the full name of the current user Source: mailvelope-client-api.js, line 156 SyncHandlerObject Type: Object Properties: Name Type Description uploadSync UploadSyncHandler function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the default private key downloadSync DownloadSyncHandler function called by Mailvelope to download the encrypted keyring (public keys) backup BackupSyncHandler function called by Mailvelope to upload a symmetrically encrypted private key backup restore RestoreSyncHandler function called by Mailvelope to restore a private key backup Source: mailvelope-client-api.js, line 406 UploadSyncHandler(uploadObj) Parameters: Name Type Description uploadObj Object object with upload data Properties Name Type Description eTag string entity tag for the uploaded encrypted keyring, or null if initial upload keyringMsg AsciiArmored encrypted keyring as PGP armored message Source: mailvelope-client-api.js, line 367 Returns: if version on server has different eTag, then the promise is rejected if server is initial and uploadObj.eTag is not null, then the promise is rejected Type Promise.&lt;UploadSyncReply, Error&gt; UploadSyncReply Type: Object Properties: Name Type Description eTag String entity tag for the uploaded encrypted keyring Source: mailvelope-client-api.js, line 362 UserId Type: Object Properties: Name Type Description email string the email address of the current user fullName string the full name of the current user Source: mailvelope-client-api.js, line 299 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Classes Classes Editor Generator KeyBackupPopup Keyring Mailvelope OpenPGPEncryptedForm RestoreBackup × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Tutorials Classes Editor Generator KeyBackupPopup Keyring Mailvelope OpenPGPEncryptedForm RestoreBackup × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Basic UsageThe Mailvelope extension injects a script into the page to make its client-api accessible.The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. EventsmailvelopeThe event will be triggered once the window.mailvelope object is available.Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }());mailvelope-disconnectThe event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time.Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false);PromisesThe client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this newlanguage feature, although adding support is in discussion. Due to this reasonwe will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actuallybe thrown by the function returning the promise. × Search results Close "},"Editor.html":{"id":"Editor.html","title":"Class: Editor","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Class: Editor Editor Not accessible, instance can be obtained using Mailvelope#createEditorContainer. new Editor(editorId) Parameters: Name Type Description editorId string the internal id of the editor Source: mailvelope-client-api.js, line 511 Methods createDraft() Encrypt and sign the content of the editor with the default key of the user.To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method. Source: mailvelope-client-api.js, line 540 Throws: error.code = 'ENCRYPT_IN_PROGRESS' error.code = 'NO_KEY_FOR_ENCRYPTION' error.code = 'ENCRYPT_QUOTA_SIZE' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; encrypt(recipients) Requests the encryption of the editor content for the given recipients. Parameters: Name Type Description recipients Array.&lt;string&gt; list of email addresses for public key lookup and encryption Source: mailvelope-client-api.js, line 528 Throws: error.code = 'ENCRYPT_IN_PROGRESS' error.code = 'NO_KEY_FOR_RECIPIENT' error.code = 'ENCRYPT_QUOTA_SIZE' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; Example editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) { console.log('encrypt', armoredMessage); // prints: \"-----BEGIN PGP MESSAGE...\" } × Search results Close "},"Generator.html":{"id":"Generator.html","title":"Class: Generator","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Class: Generator Generator Not accessible, instance can be obtained using Keyring#createKeyGenContainer. new Generator(generatorId) Parameters: Name Type Description generatorId string the internal id of the generator Source: mailvelope-client-api.js, line 463 Methods generate( [confirm]) Generate a private key Parameters: Name Type Argument Description confirm Promise.&lt;undefined, Error&gt; &lt;optional&gt; newly generate key is only persisted if Promise resolves, in the reject or timeout case the generated key is rejected Source: mailvelope-client-api.js, line 475 Throws: Error Returns: the newly generated key (public part) Type Promise.&lt;AsciiArmored, Error&gt; × Search results Close "},"KeyBackupPopup.html":{"id":"KeyBackupPopup.html","title":"Class: KeyBackupPopup","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Class: KeyBackupPopup KeyBackupPopup Not accessible, instance can be obtained using Keyring#createKeyBackupContainer new KeyBackupPopup(popupId) Parameters: Name Type Description popupId string Source: mailvelope-client-api.js, line 445 Methods isReady() Source: mailvelope-client-api.js, line 454 Throws: Error Returns: key backup ready or error Type Promise.&lt;undefined, Error&gt; × Search results Close "},"Keyring.html":{"id":"Keyring.html","title":"Class: Keyring","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Class: Keyring Keyring Not accessible, instance can be obtained using Mailvelope#getKeyringor Mailvelope#createKeyring. new Keyring(identifier, options) Parameters: Name Type Description identifier string the keyring identifier options object the options Properties: Name Type Description logoRev number revision number of the keyring logo, initial value: 0 Source: mailvelope-client-api.js, line 213 Methods addSyncHandler(syncHandlerObj) Add various functions for keyring synchronization Parameters: Name Type Description syncHandlerObj SyncHandlerObject Source: mailvelope-client-api.js, line 419 Returns: Type Promise.&lt;undefined, Error&gt; createKeyBackupContainer(selector, options) Creates an iframe to initiate the key backup process. Parameters: Name Type Description selector CssSelector target container options KeyBackupContainerOptions Source: mailvelope-client-api.js, line 334 Returns: Type Promise.&lt;KeyBackupPopup, Error&gt; createKeyGenContainer(selector, options) Creates an iframe to display the key generation container.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container options KeyGenContainerOptions Source: mailvelope-client-api.js, line 319 Throws: error.code = 'INPUT_NOT_VALID' Type Error Returns: Type Promise.&lt;Generator, Error&gt; exportOwnPublicKey(emailAddr) Exports the public key as an ascii armored string.Only keys belonging to the user (corresponding private key exists) can be exported. Parameters: Name Type Description emailAddr string email address to identify the public+private key Source: mailvelope-client-api.js, line 259 Throws: error.code = 'NO_KEY_FOR_ADDRESS' Type Error Returns: Type Promise.&lt;AsciiArmored, Error&gt; Example keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) { console.log('exportOwnPublicKey', armoredPublicKey); // prints: \"-----BEGIN PGP PUBLIC KEY BLOCK...\" }); hasPrivateKey(fingerprint) Check if keyring contains valid private key with given fingerprint Parameters: Name Type Description fingerprint string Source: mailvelope-client-api.js, line 358 Returns: Type Promise.&lt;boolean, Error&gt; importPublicKey(armored) Asks the user if they want to import the public key. Parameters: Name Type Description armored AsciiArmored public key to import Source: mailvelope-client-api.js, line 273 Throws: error.code = 'IMPORT_ERROR' error.code = 'WRONG_ARMORED_TYPE' Type Error Returns: 'IMPORTED' - key has been imported 'UPDATED' - key already in keyring, new key merged with existing key 'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) 'REJECTED' - key import rejected by user Type Promise.&lt;String, Error&gt; openSettings() Open the extension settings in a new browser tab Source: mailvelope-client-api.js, line 436 Returns: Type Promise.&lt;undefined, Error&gt; restoreBackupContainer(selector, options) Creates an iframe to restore the backup. Parameters: Name Type Description selector CssSelector target container options PrivateKeyContainerOptions Source: mailvelope-client-api.js, line 349 Returns: Type Promise.&lt;undefined, Error&gt; setLogo(dataURL, revision) Set logo for keyring. The image is persisted in Mailvelope with a revision number,therefore the method is only required after new keyring generation or if logo and revision number changes. Parameters: Name Type Description dataURL string data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png revision number revision number Source: mailvelope-client-api.js, line 293 Throws: error.code = 'LOGO_INVALID' error.code = 'REVISION_INVALID' Type Error Returns: Type Promise.&lt;undefined, Error&gt; Example keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() { // keyring.logoRev == 3 }).catch(function(error) { // logo update failed }); validKeyForAddress(recipients) Checks for valid key in the keyring for provided email addresses Parameters: Name Type Description recipients Array list of email addresses for key lookup Source: mailvelope-client-api.js, line 235 Returns: an object that maps email addresses to a status or key info object (false: no valid key, {}: valid key) Type Promise.&lt;Object, Error&gt; Example keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) { console.log(result); // { // 'abc@web.de': false, // 'info@mailvelope.com': { // keys: [ // {fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST)} // ] // } }); × Search results Close "},"Mailvelope.html":{"id":"Mailvelope.html","title":"Class: Mailvelope","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Class: Mailvelope Mailvelope Not accessible, see Readme instead on how to obtain access to an instance. new Mailvelope() Source: mailvelope-client-api.js, line 32 Methods createDisplayContainer(selector, armored, keyring, options) Creates an iframe to display the decrypted content of the encrypted mail.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container armored AsciiArmored the encrypted mail to display keyring Keyring the keyring to use for this operation options DisplayContainerOptions Source: mailvelope-client-api.js, line 100 Returns: Type Promise.&lt;DisplayContainer, Error&gt; createEditorContainer(selector, keyring, options) Creates an iframe with an editor for a new encrypted mail.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container keyring Keyring the keyring to use for this operation options EditorContainerOptions Source: mailvelope-client-api.js, line 147 Throws: error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type error.code = 'INVALID_OPTIONS' - invalid combination of options parameter Type Error Returns: Type Promise.&lt;Editor, Error&gt; Example mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) { // register event handler for mail client send button $('#mailer-send').click(function() { // encrypt current content of editor for array of recipients editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) { console.log('encrypted message', armored); }); }); }); createEncryptedFormContainer(@param, @param, @param) Creates an iframe to display an encrypted formThe iframe will be injected into the container identified by selector. Parameters: Name Type Description @param string selector - the id of target container @param string formHtml - the form definition @param string signature - the OpenPGP signature Source: mailvelope-client-api.js, line 188 Throws: error.code = 'INVALID_FORM' the form definition is not valid Type Error Returns: an object that includes armoredData Type Promise.&lt;Object, Error&gt; createKeyring(identifier) Creates a Keyring for the given identifier Parameters: Name Type Description identifier string the identifier of the new keyring Source: mailvelope-client-api.js, line 62 Throws: error.code = 'KEYRING_ALREADY_EXISTS' Type Error Returns: Type Promise.&lt;Keyring, Error&gt; Example mailvelope.createKeyring('Account-ID-4711').then(function(keyring) { // continue to display the settings container and start the setup wizard mailvelope.createSettingsContainer('#mailvelope-settings', keyring); }); createSettingsContainer(selector, keyring, options) Creates an iframe to display the keyring settings.The iframe will be injected into the container identified by selector. Parameters: Name Type Description selector CssSelector target container keyring Keyring the keyring to use for the setup options SettingsContainerOptions Source: mailvelope-client-api.js, line 170 Returns: Type Promise.&lt;undefined, Error&gt; getKeyring(identifier) Retrieves the Keyring for the given identifier Parameters: Name Type Description identifier string the identifier of the keyring Source: mailvelope-client-api.js, line 47 Throws: error.code = 'NO_KEYRING_FOR_ID' Type Error Returns: Type Promise.&lt;Keyring, Error&gt; getVersion() Gives access to the mailvelope extension version Source: mailvelope-client-api.js, line 37 Returns: Type Promise.&lt;String, Error&gt; × Search results Close "},"OpenPGPEncryptedForm.html":{"id":"OpenPGPEncryptedForm.html","title":"Class: OpenPGPEncryptedForm","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Class: OpenPGPEncryptedForm OpenPGPEncryptedForm OpenPGPEncryptedForm custom HTMLElement new OpenPGPEncryptedForm() Source: mailvelope-client-api.js, line 690 × Search results Close "},"RestoreBackup.html":{"id":"RestoreBackup.html","title":"Class: RestoreBackup","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Class: RestoreBackup RestoreBackup Not accessible, instance can be obtained using Keyring#restoreBackupContainer. new RestoreBackup(restoreId) Parameters: Name Type Description restoreId string the internal id of the restore backup Source: mailvelope-client-api.js, line 493 Methods isReady() Source: mailvelope-client-api.js, line 502 Throws: Error Returns: key restore ready or error Type Promise.&lt;undefined, Error&gt; × Search results Close "},"tutorial-Readme.html":{"id":"tutorial-Readme.html","title":"Tutorial: Readme","body":" Mailvelope API Classes EditorGeneratorKeyBackupPopupKeyringMailvelopeOpenPGPEncryptedFormRestoreBackup Tutorials Readme Global mailvelope Readme Basic UsageThe Mailvelope extension injects a script into the page to make its client-api accessible.The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. EventsmailvelopeThe event will be triggered once the window.mailvelope object is available.Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }());mailvelope-disconnectThe event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time.Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false);PromisesThe client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this newlanguage feature, although adding support is in discussion. Due to this reasonwe will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actuallybe thrown by the function returning the promise. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
